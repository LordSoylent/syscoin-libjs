/**
 * Syscoin API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Account } from '../model/account';
import { AddMultisigAddressRequest } from '../model/addMultisigAddressRequest';
import { EncryptWalletRequest } from '../model/encryptWalletRequest';
import { ErrorResponse } from '../model/errorResponse';
import { GetBlockResponse } from '../model/getBlockResponse';
import { GetBlockchainInfoResponse } from '../model/getBlockchainInfoResponse';
import { GetNewAddressRequest } from '../model/getNewAddressRequest';
import { ImportAddressRequest } from '../model/importAddressRequest';
import { ImportPrivKeyRequest } from '../model/importPrivKeyRequest';
import { ImportPubKeyRequest } from '../model/importPubKeyRequest';
import { ImportWalletRequest } from '../model/importWalletRequest';
import { Info } from '../model/info';
import { ListReceivedByAddress } from '../model/listReceivedByAddress';
import { ListSinceBlockResponse } from '../model/listSinceBlockResponse';
import { MiningInfo } from '../model/miningInfo';
import { MoveRequest } from '../model/moveRequest';
import { NetworkInfo } from '../model/networkInfo';
import { PeerInfoResponse } from '../model/peerInfoResponse';
import { SendFromRequest } from '../model/sendFromRequest';
import { SendManyRequest } from '../model/sendManyRequest';
import { SendToAddressRequest } from '../model/sendToAddressRequest';
import { SignMessageRequest } from '../model/signMessageRequest';
import { SyscoinAddressEntry } from '../model/syscoinAddressEntry';
import { Transaction } from '../model/transaction';
import { TransactionListEntry } from '../model/transactionListEntry';
import { ValidateAddressResponse } from '../model/validateAddressResponse';
import { WalletInfo } from '../model/walletInfo';
import { WalletPassphraseChangeRequest } from '../model/walletPassphraseChangeRequest';
import { WalletPassphraseRequest } from '../model/walletPassphraseRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class GeneralService {

    protected basePath = 'http://localhost:8001';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * Add a nrequired-to-sign multisignature address to the wallet. Each key is a Syscoin address or hex-encoded public key. If &#39;account&#39; is specified (DEPRECATED), assign address to that account.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addmultisigaddress(request: AddMultisigAddressRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public addmultisigaddress(request: AddMultisigAddressRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public addmultisigaddress(request: AddMultisigAddressRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public addmultisigaddress(request: AddMultisigAddressRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling addmultisigaddress.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/addmultisigaddress`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Reveals the private key corresponding to &#39;syscoinaddress&#39;. Then the importprivkey can be used with this output.
     * @param address The syscoin address for the private key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dumpprivkey(address: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public dumpprivkey(address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public dumpprivkey(address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public dumpprivkey(address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling dumpprivkey.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address !== undefined) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/dumpprivkey`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Dumps all wallet keys in a human-readable format.
     * @param filename The filename
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dumpwallet(filename: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public dumpwallet(filename: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public dumpwallet(filename: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public dumpwallet(filename: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling dumpwallet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filename !== undefined) {
            queryParameters = queryParameters.set('filename', <any>filename);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/dumpwallet`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Encrypts the wallet with &#39;passphrase&#39;. This is for first time encryption. After this, any calls that interact with private keys such as sending or signing will require the passphrase to be set prior the making these calls. Use the walletpassphrase call for this, and then walletlock call. If the wallet is already encrypted, use the walletpassphrasechange call. Note that this will shutdown the server.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public encryptwallet(request: EncryptWalletRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public encryptwallet(request: EncryptWalletRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public encryptwallet(request: EncryptWalletRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public encryptwallet(request: EncryptWalletRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling encryptwallet.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/encryptwallet`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Mine up to numblocks blocks immediately (before the RPC call returns).
     * @param numBlocks How many blocks are generated immediately.
     * @param maxtries ﻿How many iterations to try (default &#x3D; 1000000).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public generate(numBlocks: number, maxtries?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public generate(numBlocks: number, maxtries?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public generate(numBlocks: number, maxtries?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public generate(numBlocks: number, maxtries?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (numBlocks === null || numBlocks === undefined) {
            throw new Error('Required parameter numBlocks was null or undefined when calling generate.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (numBlocks !== undefined) {
            queryParameters = queryParameters.set('numBlocks', <any>numBlocks);
        }
        if (maxtries !== undefined) {
            queryParameters = queryParameters.set('maxtries', <any>maxtries);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/generate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Generates a public key for a wallet.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public generatepublickey(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public generatepublickey(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public generatepublickey(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public generatepublickey(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/generatepublickey`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. Returns the account associated with the given address.
     * @param syscoinaddress The syscoin address for account lookup.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getaccount(syscoinaddress: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getaccount(syscoinaddress: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getaccount(syscoinaddress: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getaccount(syscoinaddress: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling getaccount.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (syscoinaddress !== undefined) {
            queryParameters = queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/getaccount`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. Returns the current Syscoin address for receiving payments to this account.
     * @param account The account name for the address. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getaccountaddress(account: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getaccountaddress(account: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getaccountaddress(account: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getaccountaddress(account: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getaccountaddress.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (account !== undefined) {
            queryParameters = queryParameters.set('account', <any>account);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/getaccountaddress`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. Returns the list of addresses for the given account.
     * @param account 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getaddressesbyaccount(account: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getaddressesbyaccount(account: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getaddressesbyaccount(account: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getaddressesbyaccount(account: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getaddressesbyaccount.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (account !== undefined) {
            queryParameters = queryParameters.set('account', <any>account);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/getaddressesbyaccount`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * If account is not specified, returns the server&#39;s total available balance. If account is specified (DEPRECATED), returns the balance in the account. Note that the account \&quot;\&quot; is not the same as leaving the parameter out. The server total may be different to the balance in the default \&quot;\&quot; account.
     * @param account DEPRECATED. The selected account, or \&quot;*\&quot; for entire wallet. It may be the default account using \&quot;\&quot;.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeWatchonly Also include balance in watchonly addresses (see &#39;importaddress&#39;)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getbalance(account?: string, minconf?: number, includeWatchonly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getbalance(account?: string, minconf?: number, includeWatchonly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getbalance(account?: string, minconf?: number, includeWatchonly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getbalance(account?: string, minconf?: number, includeWatchonly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (account !== undefined) {
            queryParameters = queryParameters.set('account', <any>account);
        }
        if (minconf !== undefined) {
            queryParameters = queryParameters.set('minconf', <any>minconf);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/getbalance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * ﻿If verbose is false, returns a string that is serialized, hex-encoded data for block &#39;hash&#39;. If verbose is true, returns an Object with information about block &lt;hash&gt;.
     * @param hash 
     * @param verbose 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getblock(hash: string, verbose?: boolean, observe?: 'body', reportProgress?: boolean): Observable<GetBlockResponse>;
    public getblock(hash: string, verbose?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetBlockResponse>>;
    public getblock(hash: string, verbose?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetBlockResponse>>;
    public getblock(hash: string, verbose?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling getblock.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (hash !== undefined) {
            queryParameters = queryParameters.set('hash', <any>hash);
        }
        if (verbose !== undefined) {
            queryParameters = queryParameters.set('verbose', <any>verbose);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetBlockResponse>(`${this.basePath}/getblock`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns an object containing various state info regarding block chain processing.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getblockchaininfo(observe?: 'body', reportProgress?: boolean): Observable<GetBlockchainInfoResponse>;
    public getblockchaininfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetBlockchainInfoResponse>>;
    public getblockchaininfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetBlockchainInfoResponse>>;
    public getblockchaininfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetBlockchainInfoResponse>(`${this.basePath}/getblockchaininfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the number of blocks in the longest block chain.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getblockcount(observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getblockcount(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getblockcount(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getblockcount(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/getblockcount`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns an object containing various state info.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getinfo(observe?: 'body', reportProgress?: boolean): Observable<Info>;
    public getinfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Info>>;
    public getinfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Info>>;
    public getinfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Info>(`${this.basePath}/getinfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a json object containing mining-related information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getmininginfo(observe?: 'body', reportProgress?: boolean): Observable<MiningInfo>;
    public getmininginfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MiningInfo>>;
    public getmininginfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MiningInfo>>;
    public getmininginfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<MiningInfo>(`${this.basePath}/getmininginfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a json object containing network-related information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getnetworkinfo(observe?: 'body', reportProgress?: boolean): Observable<NetworkInfo>;
    public getnetworkinfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NetworkInfo>>;
    public getnetworkinfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NetworkInfo>>;
    public getnetworkinfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<NetworkInfo>(`${this.basePath}/getnetworkinfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a new Syscoin address for receiving payments. If &#39;account&#39; is specified (DEPRECATED), it is added to the address book so payments received with the address will be credited to &#39;account&#39;.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getnewaddress(request?: GetNewAddressRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getnewaddress(request?: GetNewAddressRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getnewaddress(request?: GetNewAddressRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getnewaddress(request?: GetNewAddressRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/getnewaddress`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns data about each connected network node as a json array of objects.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getpeerinfo(observe?: 'body', reportProgress?: boolean): Observable<PeerInfoResponse>;
    public getpeerinfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PeerInfoResponse>>;
    public getpeerinfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PeerInfoResponse>>;
    public getpeerinfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<PeerInfoResponse>(`${this.basePath}/getpeerinfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. Returns the total amount received by addresses with &lt;account&gt; in transactions with at least [minconf] confirmations.
     * @param account The selected account, may be the default account using \&quot;\&quot;.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getreceivedbyaccount(account: string, minconf?: number, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getreceivedbyaccount(account: string, minconf?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getreceivedbyaccount(account: string, minconf?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getreceivedbyaccount(account: string, minconf?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getreceivedbyaccount.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (account !== undefined) {
            queryParameters = queryParameters.set('account', <any>account);
        }
        if (minconf !== undefined) {
            queryParameters = queryParameters.set('minconf', <any>minconf);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/getreceivedbyaccount`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the total amount received by the given syscoinaddress in transactions with at least minconf confirmations.
     * @param syscoinaddress The syscoin address for transactions.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getreceivedbyaddress(syscoinaddress: string, minconf?: number, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getreceivedbyaddress(syscoinaddress: string, minconf?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getreceivedbyaddress(syscoinaddress: string, minconf?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getreceivedbyaddress(syscoinaddress: string, minconf?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling getreceivedbyaddress.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (syscoinaddress !== undefined) {
            queryParameters = queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }
        if (minconf !== undefined) {
            queryParameters = queryParameters.set('minconf', <any>minconf);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/getreceivedbyaddress`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Get detailed information about in-wallet transaction &lt;txid&gt;
     * @param txid The transaction id
     * @param includeWatchonly Whether to include watchonly addresses in balance calculation and details[]
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public gettransaction(txid: string, includeWatchonly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public gettransaction(txid: string, includeWatchonly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public gettransaction(txid: string, includeWatchonly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public gettransaction(txid: string, includeWatchonly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling gettransaction.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (txid !== undefined) {
            queryParameters = queryParameters.set('txid', <any>txid);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Transaction>(`${this.basePath}/gettransaction`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the server&#39;s total unconfirmed balance
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getunconfirmedbalance(observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getunconfirmedbalance(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getunconfirmedbalance(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getunconfirmedbalance(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/getunconfirmedbalance`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a new Syscoin (starts with 1) address for receiving payments. If &#39;account&#39; is specified (DEPRECATED), it is added to the address book so payments received with the address will be credited to &#39;account&#39;.
     * @param account DEPRECATED. The account name for the address to be linked to. If not provided, the default account \&quot;\&quot; is used. It can also be set to the empty string \&quot;\&quot; to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getv2address(account?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getv2address(account?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getv2address(account?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getv2address(account?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (account !== undefined) {
            queryParameters = queryParameters.set('account', <any>account);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/getv2address`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns wallet balance for all accounts. Does not include watch only accounts.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getwalletbalance(observe?: 'body', reportProgress?: boolean): Observable<number>;
    public getwalletbalance(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public getwalletbalance(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public getwalletbalance(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/getwalletbalance`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns an object containing various wallet state info.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getwalletinfo(observe?: 'body', reportProgress?: boolean): Observable<WalletInfo>;
    public getwalletinfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletInfo>>;
    public getwalletinfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletInfo>>;
    public getwalletinfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<WalletInfo>(`${this.basePath}/getwalletinfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a new ZCash address for receiving payments in ZCash transaparent tokens. so payments received with the address will be credited to &#39;account&#39;.
     * @param address 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getzaddress(address: string, observe?: 'body', reportProgress?: boolean): Observable<WalletInfo>;
    public getzaddress(address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletInfo>>;
    public getzaddress(address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletInfo>>;
    public getzaddress(address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getzaddress.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address !== undefined) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<WalletInfo>(`${this.basePath}/getzaddress`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Adds a script (in hex) or address that can be watched as if it were in your wallet but cannot be used to spend.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public importaddress(request: ImportAddressRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public importaddress(request: ImportAddressRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public importaddress(request: ImportAddressRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public importaddress(request: ImportAddressRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importaddress.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/importaddress`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Adds a private key (as returned by dumpprivkey) to your wallet.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public importprivkey(request: ImportPrivKeyRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public importprivkey(request: ImportPrivKeyRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public importprivkey(request: ImportPrivKeyRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public importprivkey(request: ImportPrivKeyRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importprivkey.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/importprivkey`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Imports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.
     * @param rawtransaction 
     * @param txoutproof 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public importprunedfunds(rawtransaction: string, txoutproof: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public importprunedfunds(rawtransaction: string, txoutproof: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public importprunedfunds(rawtransaction: string, txoutproof: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public importprunedfunds(rawtransaction: string, txoutproof: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (rawtransaction === null || rawtransaction === undefined) {
            throw new Error('Required parameter rawtransaction was null or undefined when calling importprunedfunds.');
        }
        if (txoutproof === null || txoutproof === undefined) {
            throw new Error('Required parameter txoutproof was null or undefined when calling importprunedfunds.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (rawtransaction !== undefined) {
            queryParameters = queryParameters.set('rawtransaction', <any>rawtransaction);
        }
        if (txoutproof !== undefined) {
            queryParameters = queryParameters.set('txoutproof', <any>txoutproof);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/importprunedfunds`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Adds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public importpubkey(request: ImportPubKeyRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public importpubkey(request: ImportPubKeyRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public importpubkey(request: ImportPubKeyRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public importpubkey(request: ImportPubKeyRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importpubkey.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/importpubkey`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Imports keys from a wallet dump file (see dumpwallet).
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public importwallet(request: ImportWalletRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public importwallet(request: ImportWalletRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public importwallet(request: ImportWalletRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public importwallet(request: ImportWalletRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling importwallet.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/importwallet`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. Returns Object that has account names as keys, account balances as values.
     * @param minconf Only include transactions with at least this many confirmations
     * @param includeWatchonly Include balances in watchonly addresses (see &#39;importaddress&#39;)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listaccounts(minconf?: number, includeWatchonly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public listaccounts(minconf?: number, includeWatchonly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public listaccounts(minconf?: number, includeWatchonly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public listaccounts(minconf?: number, includeWatchonly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (minconf !== undefined) {
            queryParameters = queryParameters.set('minconf', <any>minconf);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/listaccounts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Lists groups of addresses which have had their common ownership made public by common use as inputs or as the resulting change in past transactions
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listaddressgroupings(observe?: 'body', reportProgress?: boolean): Observable<Array<Array<AddressGrouping>>>;
    public listaddressgroupings(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Array<AddressGrouping>>>>;
    public listaddressgroupings(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Array<AddressGrouping>>>>;
    public listaddressgroupings(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Array<AddressGrouping>>>(`${this.basePath}/listaddressgroupings`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. List balances by account.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeempty Whether to include accounts that haven&#39;t received any payments.
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listreceivedbyaccount(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Account>>;
    public listreceivedbyaccount(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Account>>>;
    public listreceivedbyaccount(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Account>>>;
    public listreceivedbyaccount(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (minconf !== undefined) {
            queryParameters = queryParameters.set('minconf', <any>minconf);
        }
        if (includeempty !== undefined) {
            queryParameters = queryParameters.set('includeempty', <any>includeempty);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Account>>(`${this.basePath}/listreceivedbyaccount`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * List balances by receiving address.
     * @param minconf Only include transactions confirmed at least this many times.
     * @param includeempty Whether to include accounts that haven&#39;t received any payments.
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listreceivedbyaddress(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ListReceivedByAddress>>;
    public listreceivedbyaddress(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ListReceivedByAddress>>>;
    public listreceivedbyaddress(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ListReceivedByAddress>>>;
    public listreceivedbyaddress(minconf?: number, includeempty?: boolean, includeWatchonly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (minconf !== undefined) {
            queryParameters = queryParameters.set('minconf', <any>minconf);
        }
        if (includeempty !== undefined) {
            queryParameters = queryParameters.set('includeempty', <any>includeempty);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ListReceivedByAddress>>(`${this.basePath}/listreceivedbyaddress`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Get all transactions in blocks since block [blockhash], or all transactions if omitted
     * @param blockhash The block hash to list transactions since
     * @param includeWatchonly Whether to include watchonly addresses (see &#39;importaddress&#39;).
     * @param target_confirmations 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listsinceblock(blockhash?: string, includeWatchonly?: boolean, target_confirmations?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ListSinceBlockResponse>>;
    public listsinceblock(blockhash?: string, includeWatchonly?: boolean, target_confirmations?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ListSinceBlockResponse>>>;
    public listsinceblock(blockhash?: string, includeWatchonly?: boolean, target_confirmations?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ListSinceBlockResponse>>>;
    public listsinceblock(blockhash?: string, includeWatchonly?: boolean, target_confirmations?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (blockhash !== undefined) {
            queryParameters = queryParameters.set('blockhash', <any>blockhash);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }
        if (target_confirmations !== undefined) {
            queryParameters = queryParameters.set('target-confirmations', <any>target_confirmations);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ListSinceBlockResponse>>(`${this.basePath}/listsinceblock`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns up to &#39;count&#39; most recent transactions skipping the first &#39;from&#39; transactions for account &#39;account&#39;.
     * @param account DEPRECATED. The account name. Should be \&quot;*\&quot;.
     * @param count The number of transactions to return
     * @param from The number of transactions to skip
     * @param includeWatchonly Include transactions to watchonly addresses (see &#39;importaddress&#39;)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listtransactions(account?: string, count?: number, from?: number, includeWatchonly?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<TransactionListEntry>>;
    public listtransactions(account?: string, count?: number, from?: number, includeWatchonly?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TransactionListEntry>>>;
    public listtransactions(account?: string, count?: number, from?: number, includeWatchonly?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TransactionListEntry>>>;
    public listtransactions(account?: string, count?: number, from?: number, includeWatchonly?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (account !== undefined) {
            queryParameters = queryParameters.set('account', <any>account);
        }
        if (count !== undefined) {
            queryParameters = queryParameters.set('count', <any>count);
        }
        if (from !== undefined) {
            queryParameters = queryParameters.set('from', <any>from);
        }
        if (includeWatchonly !== undefined) {
            queryParameters = queryParameters.set('includeWatchonly', <any>includeWatchonly);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<TransactionListEntry>>(`${this.basePath}/listtransactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED. Move a specified amount from one account in your wallet to another.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public move(request: MoveRequest, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public move(request: MoveRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public move(request: MoveRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public move(request: MoveRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling move.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<boolean>(`${this.basePath}/move`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Deletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.
     * @param txid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeprunedfunds(txid: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public removeprunedfunds(txid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public removeprunedfunds(txid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public removeprunedfunds(txid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling removeprunedfunds.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (txid !== undefined) {
            queryParameters = queryParameters.set('txid', <any>txid);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/removeprunedfunds`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * DEPRECATED (use sendtoaddress). Sent an amount from an account to a syscoin address. The amount is a real and is rounded to the nearest 0.00000001. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendfrom(request: SendFromRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public sendfrom(request: SendFromRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public sendfrom(request: SendFromRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public sendfrom(request: SendFromRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling sendfrom.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/sendfrom`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Send multiple times. Amounts are double-precision floating point numbers. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendmany(request: SendManyRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public sendmany(request: SendManyRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public sendmany(request: SendManyRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public sendmany(request: SendManyRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling sendmany.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/sendmany`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Send an amount to a given address. The amount is a real and is rounded to the nearest 0.00000001. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendtoaddress(request: SendToAddressRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public sendtoaddress(request: SendToAddressRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public sendtoaddress(request: SendToAddressRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public sendtoaddress(request: SendToAddressRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling sendtoaddress.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/sendtoaddress`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Sign a message with the private key of an address. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public signmessage(request: SignMessageRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public signmessage(request: SignMessageRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public signmessage(request: SignMessageRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public signmessage(request: SignMessageRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling signmessage.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/signmessage`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Decode raw syscoin transaction (serialized, hex-encoded) and display information pertaining to the service that is included in the transactiion data output(OP_RETURN)
     * @param alias 
     * @param hexstring 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syscoindecoderawtransaction(alias: string, hexstring: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public syscoindecoderawtransaction(alias: string, hexstring: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public syscoindecoderawtransaction(alias: string, hexstring: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public syscoindecoderawtransaction(alias: string, hexstring: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (alias === null || alias === undefined) {
            throw new Error('Required parameter alias was null or undefined when calling syscoindecoderawtransaction.');
        }
        if (hexstring === null || hexstring === undefined) {
            throw new Error('Required parameter hexstring was null or undefined when calling syscoindecoderawtransaction.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (alias !== undefined) {
            queryParameters = queryParameters.set('alias', <any>alias);
        }
        if (hexstring !== undefined) {
            queryParameters = queryParameters.set('hexstring', <any>hexstring);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/syscoindecoderawtransaction`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns all addresses and balances associated with address
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syscoinlistreceivebyaddress(observe?: 'body', reportProgress?: boolean): Observable<SyscoinAddressEntry>;
    public syscoinlistreceivebyaddress(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SyscoinAddressEntry>>;
    public syscoinlistreceivebyaddress(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SyscoinAddressEntry>>;
    public syscoinlistreceivebyaddress(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SyscoinAddressEntry>(`${this.basePath}/syscoinlistreceivebyaddress`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Sign inputs for raw transaction (serialized, hex-encoded) and sends them out to the network if signing is complete
     * @param hexstring 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syscoinsignrawtransaction(hexstring: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public syscoinsignrawtransaction(hexstring: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public syscoinsignrawtransaction(hexstring: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public syscoinsignrawtransaction(hexstring: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (hexstring === null || hexstring === undefined) {
            throw new Error('Required parameter hexstring was null or undefined when calling syscoinsignrawtransaction.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (hexstring !== undefined) {
            queryParameters = queryParameters.set('hexstring', <any>hexstring);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/syscoinsignrawtransaction`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Return information about the given syscoin address.
     * @param syscoinaddress 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public validateaddress(syscoinaddress: string, observe?: 'body', reportProgress?: boolean): Observable<ValidateAddressResponse>;
    public validateaddress(syscoinaddress: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ValidateAddressResponse>>;
    public validateaddress(syscoinaddress: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ValidateAddressResponse>>;
    public validateaddress(syscoinaddress: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling validateaddress.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (syscoinaddress !== undefined) {
            queryParameters = queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ValidateAddressResponse>(`${this.basePath}/validateaddress`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Verify a signed message
     * @param syscoinaddress The syscoin address to use for the signature.
     * @param signature The signature provided by the signer in base 64 encoding (see signmessage).
     * @param message The message that was signed.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public verifymessage(syscoinaddress: string, signature: string, message: string, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public verifymessage(syscoinaddress: string, signature: string, message: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public verifymessage(syscoinaddress: string, signature: string, message: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public verifymessage(syscoinaddress: string, signature: string, message: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (syscoinaddress === null || syscoinaddress === undefined) {
            throw new Error('Required parameter syscoinaddress was null or undefined when calling verifymessage.');
        }
        if (signature === null || signature === undefined) {
            throw new Error('Required parameter signature was null or undefined when calling verifymessage.');
        }
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling verifymessage.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (syscoinaddress !== undefined) {
            queryParameters = queryParameters.set('syscoinaddress', <any>syscoinaddress);
        }
        if (signature !== undefined) {
            queryParameters = queryParameters.set('signature', <any>signature);
        }
        if (message !== undefined) {
            queryParameters = queryParameters.set('message', <any>message);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<boolean>(`${this.basePath}/verifymessage`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Removes the wallet encryption key from memory, locking the wallet. After calling this method, you will need to call walletpassphrase again before being able to call any methods which require the wallet to be unlocked.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletlock(observe?: 'body', reportProgress?: boolean): Observable<string>;
    public walletlock(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public walletlock(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public walletlock(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'application/octet-stream'
        ];

        return this.httpClient.post<string>(`${this.basePath}/walletlock`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Stores the wallet decryption key in memory for &#39;timeout&#39; seconds. This is needed prior to performing transactions related to private keys such as sending syscoins
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletpassphrase(request: WalletPassphraseRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public walletpassphrase(request: WalletPassphraseRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public walletpassphrase(request: WalletPassphraseRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public walletpassphrase(request: WalletPassphraseRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling walletpassphrase.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/walletpassphrase`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Changes the wallet passphrase from &#39;oldpassphrase&#39; to &#39;newpassphrase&#39;.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletpassphrasechange(request: WalletPassphraseChangeRequest, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public walletpassphrasechange(request: WalletPassphraseChangeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public walletpassphrasechange(request: WalletPassphraseChangeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public walletpassphrasechange(request: WalletPassphraseChangeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling walletpassphrasechange.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/walletpassphrasechange`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
