/**
 * Syscoin API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ErrorResponse } from '../model/errorResponse';
import { Offer } from '../model/offer';
import { OfferAccept } from '../model/offerAccept';
import { OfferAcceptRequest } from '../model/offerAcceptRequest';
import { OfferAddWhitelistRequest } from '../model/offerAddWhitelistRequest';
import { OfferClearWhitelistRequest } from '../model/offerClearWhitelistRequest';
import { OfferHistoryEntry } from '../model/offerHistoryEntry';
import { OfferLinkRequest } from '../model/offerLinkRequest';
import { OfferNewRequest } from '../model/offerNewRequest';
import { OfferRemoveWhitelistRequest } from '../model/offerRemoveWhitelistRequest';
import { OfferUpdateRequest } from '../model/offerUpdateRequest';
import { OfferWhitelistEntry } from '../model/offerWhitelistEntry';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class OffersService {

    protected basePath = 'http://localhost:8001';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * Accept&amp;Pay for a confirmed offer.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offeraccept(request: OfferAcceptRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offeraccept(request: OfferAcceptRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offeraccept(request: OfferAcceptRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offeraccept(request: OfferAcceptRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offeraccept.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offeraccept`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Acknowledge offer payment as seller of offer. Deducts qty of offer and increases number of sold inventory.
     * @param offerguid 
     * @param offeracceptguid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offeracceptacknowledge(offerguid: string, offeracceptguid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offeracceptacknowledge(offerguid: string, offeracceptguid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offeracceptacknowledge(offerguid: string, offeracceptguid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offeracceptacknowledge(offerguid: string, offeracceptguid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offeracceptacknowledge.');
        }
        if (offeracceptguid === null || offeracceptguid === undefined) {
            throw new Error('Required parameter offeracceptguid was null or undefined when calling offeracceptacknowledge.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offerguid !== undefined) {
            queryParameters = queryParameters.set('offerguid', <any>offerguid);
        }
        if (offeracceptguid !== undefined) {
            queryParameters = queryParameters.set('offeracceptguid', <any>offeracceptguid);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Array<string>>(`${this.basePath}/offeracceptacknowledge`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * List count of offer accept for a set of aliases. filterpurchases filters results for count of accepts that have been bought with aliases passed in(as buyer), filtersales filters results for count of accepts purchased by aliases passed in(as merchant or affiliate).
     * @param aliases 
     * @param filterpurchases 
     * @param filtersales 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offeracceptcount(aliases?: Array<string>, filterpurchases?: boolean, filtersales?: boolean, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public offeracceptcount(aliases?: Array<string>, filterpurchases?: boolean, filtersales?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public offeracceptcount(aliases?: Array<string>, filterpurchases?: boolean, filtersales?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public offeracceptcount(aliases?: Array<string>, filterpurchases?: boolean, filtersales?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (aliases) {
            queryParameters = queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }
        if (filterpurchases !== undefined) {
            queryParameters = queryParameters.set('filterpurchases', <any>filterpurchases);
        }
        if (filtersales !== undefined) {
            queryParameters = queryParameters.set('filtersales', <any>filtersales);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/offeracceptcount`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Send feedback and rating for offer accept specified. Ratings are numbers from 1 to 5
     * @param offerguid 
     * @param offeracceptguid 
     * @param feedback 
     * @param rating 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offeracceptfeedback(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offeracceptfeedback(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offeracceptfeedback(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offeracceptfeedback(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offeracceptfeedback.');
        }
        if (offeracceptguid === null || offeracceptguid === undefined) {
            throw new Error('Required parameter offeracceptguid was null or undefined when calling offeracceptfeedback.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offerguid !== undefined) {
            queryParameters = queryParameters.set('offerguid', <any>offerguid);
        }
        if (offeracceptguid !== undefined) {
            queryParameters = queryParameters.set('offeracceptguid', <any>offeracceptguid);
        }
        if (feedback !== undefined) {
            queryParameters = queryParameters.set('feedback', <any>feedback);
        }
        if (rating !== undefined) {
            queryParameters = queryParameters.set('rating', <any>rating);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Array<string>>(`${this.basePath}/offeracceptfeedback`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * List offer accepts for a set of aliases. filterpurchases filters results for accepts that have been bought with aliases passed in(as buyer), filtersales filters results for accepts purchased by aliases passed in(as merchant or affiliate).
     * @param aliases 
     * @param guid 
     * @param filterpurchases 
     * @param filtersales 
     * @param count The number of results to return
     * @param from The number of results to skip
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offeracceptlist(aliases?: Array<string>, guid?: string, filterpurchases?: boolean, filtersales?: boolean, count?: number, from?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<OfferAccept>>;
    public offeracceptlist(aliases?: Array<string>, guid?: string, filterpurchases?: boolean, filtersales?: boolean, count?: number, from?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<OfferAccept>>>;
    public offeracceptlist(aliases?: Array<string>, guid?: string, filterpurchases?: boolean, filtersales?: boolean, count?: number, from?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<OfferAccept>>>;
    public offeracceptlist(aliases?: Array<string>, guid?: string, filterpurchases?: boolean, filtersales?: boolean, count?: number, from?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (aliases) {
            queryParameters = queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }
        if (guid !== undefined) {
            queryParameters = queryParameters.set('guid', <any>guid);
        }
        if (filterpurchases !== undefined) {
            queryParameters = queryParameters.set('filterpurchases', <any>filterpurchases);
        }
        if (filtersales !== undefined) {
            queryParameters = queryParameters.set('filtersales', <any>filtersales);
        }
        if (count !== undefined) {
            queryParameters = queryParameters.set('count', <any>count);
        }
        if (from !== undefined) {
            queryParameters = queryParameters.set('from', <any>from);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<OfferAccept>>(`${this.basePath}/offeracceptlist`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Add to the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offeraddwhitelist(request: OfferAddWhitelistRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offeraddwhitelist(request: OfferAddWhitelistRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offeraddwhitelist(request: OfferAddWhitelistRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offeraddwhitelist(request: OfferAddWhitelistRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offeraddwhitelist.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offeraddwhitelist`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Clear the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerclearwhitelist(request: OfferClearWhitelistRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offerclearwhitelist(request: OfferClearWhitelistRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offerclearwhitelist(request: OfferClearWhitelistRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offerclearwhitelist(request: OfferClearWhitelistRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerclearwhitelist.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offerclearwhitelist`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Count offers that an array of aliases own.
     * @param aliases 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offercount(aliases?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public offercount(aliases?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public offercount(aliases?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public offercount(aliases?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (aliases) {
            queryParameters = queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<number>(`${this.basePath}/offercount`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * scan and filter offers
     * @param regexp apply [regexp] on offeres, empty means all offers
     * @param from show results from number [from]
     * @param count the number of results to return
     * @param safesearch shows all offers that are safe to display (not on the ban list)
     * @param category Category you want to search in, empty for all
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerfilter(regexp?: string, from?: string, count?: number, safesearch?: string, category?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Offer>>;
    public offerfilter(regexp?: string, from?: string, count?: number, safesearch?: string, category?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Offer>>>;
    public offerfilter(regexp?: string, from?: string, count?: number, safesearch?: string, category?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Offer>>>;
    public offerfilter(regexp?: string, from?: string, count?: number, safesearch?: string, category?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (regexp !== undefined) {
            queryParameters = queryParameters.set('regexp', <any>regexp);
        }
        if (from !== undefined) {
            queryParameters = queryParameters.set('from', <any>from);
        }
        if (count !== undefined) {
            queryParameters = queryParameters.set('count', <any>count);
        }
        if (safesearch !== undefined) {
            queryParameters = queryParameters.set('safesearch', <any>safesearch);
        }
        if (category !== undefined) {
            queryParameters = queryParameters.set('category', <any>category);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Offer>>(`${this.basePath}/offerfilter`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * List all stored values of an offer.
     * @param offer Offer GUID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerhistory(offer: string, observe?: 'body', reportProgress?: boolean): Observable<Array<OfferHistoryEntry>>;
    public offerhistory(offer: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<OfferHistoryEntry>>>;
    public offerhistory(offer: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<OfferHistoryEntry>>>;
    public offerhistory(offer: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (offer === null || offer === undefined) {
            throw new Error('Required parameter offer was null or undefined when calling offerhistory.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offer !== undefined) {
            queryParameters = queryParameters.set('offer', <any>offer);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<OfferHistoryEntry>>(`${this.basePath}/offerhistory`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Show values of an offer.
     * @param guid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerinfo(guid: string, observe?: 'body', reportProgress?: boolean): Observable<Offer>;
    public offerinfo(guid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Offer>>;
    public offerinfo(guid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Offer>>;
    public offerinfo(guid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling offerinfo.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (guid !== undefined) {
            queryParameters = queryParameters.set('guid', <any>guid);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Offer>(`${this.basePath}/offerinfo`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerlink(request: OfferLinkRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offerlink(request: OfferLinkRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offerlink(request: OfferLinkRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offerlink(request: OfferLinkRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerlink.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offerlink`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * list offers that an array of aliases own.
     * @param aliases 
     * @param guid 
     * @param count The number of results to return
     * @param from The number of results to skip
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerlist(aliases?: Array<string>, guid?: string, count?: number, from?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Offer>>;
    public offerlist(aliases?: Array<string>, guid?: string, count?: number, from?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Offer>>>;
    public offerlist(aliases?: Array<string>, guid?: string, count?: number, from?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Offer>>>;
    public offerlist(aliases?: Array<string>, guid?: string, count?: number, from?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (aliases) {
            queryParameters = queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }
        if (guid !== undefined) {
            queryParameters = queryParameters.set('guid', <any>guid);
        }
        if (count !== undefined) {
            queryParameters = queryParameters.set('count', <any>count);
        }
        if (from !== undefined) {
            queryParameters = queryParameters.set('from', <any>from);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Offer>>(`${this.basePath}/offerlist`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Create a new offer on the Syscoin decentralized marketplace. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offernew(request: OfferNewRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offernew(request: OfferNewRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offernew(request: OfferNewRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offernew(request: OfferNewRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offernew.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offernew`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Remove from the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerremovewhitelist(request: OfferRemoveWhitelistRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offerremovewhitelist(request: OfferRemoveWhitelistRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offerremovewhitelist(request: OfferRemoveWhitelistRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offerremovewhitelist(request: OfferRemoveWhitelistRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerremovewhitelist.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offerremovewhitelist`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Perform an update on an offer you control. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerupdate(request: OfferUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public offerupdate(request: OfferUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public offerupdate(request: OfferUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public offerupdate(request: OfferUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerupdate.');
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<string>>(`${this.basePath}/offerupdate`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * List all affiliates for this offer.
     * @param offerguid 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public offerwhitelist(offerguid: string, observe?: 'body', reportProgress?: boolean): Observable<Array<OfferWhitelistEntry>>;
    public offerwhitelist(offerguid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<OfferWhitelistEntry>>>;
    public offerwhitelist(offerguid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<OfferWhitelistEntry>>>;
    public offerwhitelist(offerguid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offerwhitelist.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offerguid !== undefined) {
            queryParameters = queryParameters.set('offerguid', <any>offerguid);
        }

        let headers = this.defaultHeaders;

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers = headers.set('token', this.configuration.apiKeys["token"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<OfferWhitelistEntry>>(`${this.basePath}/offerwhitelist`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
