/**
 * Syscoin API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { ErrorResponse } from '../model/errorResponse';
import { Offer } from '../model/offer';
import { OfferAccept } from '../model/offerAccept';
import { OfferAcceptRequest } from '../model/offerAcceptRequest';
import { OfferAddWhitelistRequest } from '../model/offerAddWhitelistRequest';
import { OfferClearWhitelistRequest } from '../model/offerClearWhitelistRequest';
import { OfferHistoryEntry } from '../model/offerHistoryEntry';
import { OfferLinkRequest } from '../model/offerLinkRequest';
import { OfferNewRequest } from '../model/offerNewRequest';
import { OfferRemoveWhitelistRequest } from '../model/offerRemoveWhitelistRequest';
import { OfferUpdateRequest } from '../model/offerUpdateRequest';
import { OfferWhitelistEntry } from '../model/offerWhitelistEntry';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class OffersService {

    protected basePath = 'http://localhost:8001';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
			this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * Accept&Pay for a confirmed offer.
     * @param request 
     */
    public offeraccept(request: OfferAcceptRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeracceptWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Acknowledge offer payment as seller of offer. Deducts qty of offer and increases number of sold inventory.
     * @param offerguid 
     * @param offeracceptguid 
     */
    public offeracceptacknowledge(offerguid: string, offeracceptguid: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeracceptacknowledgeWithHttpInfo(offerguid, offeracceptguid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * List count of offer accept for a set of aliases. filterpurchases filters results for count of accepts that have been bought with aliases passed in(as buyer), filtersales filters results for count of accepts purchased by aliases passed in(as merchant or affiliate).
     * @param aliases 
     * @param filterpurchases 
     * @param filtersales 
     */
    public offeracceptcount(aliases?: Array<string>, filterpurchases?: boolean, filtersales?: boolean, extraHttpRequestParams?: any): Observable<number> {
        return this.offeracceptcountWithHttpInfo(aliases, filterpurchases, filtersales, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Send feedback and rating for offer accept specified. Ratings are numbers from 1 to 5
     * @param offerguid 
     * @param offeracceptguid 
     * @param feedback 
     * @param rating 
     */
    public offeracceptfeedback(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeracceptfeedbackWithHttpInfo(offerguid, offeracceptguid, feedback, rating, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * List offer accepts for a set of aliases. filterpurchases filters results for accepts that have been bought with aliases passed in(as buyer), filtersales filters results for accepts purchased by aliases passed in(as merchant or affiliate).
     * @param aliases 
     * @param guid 
     * @param filterpurchases 
     * @param filtersales 
     * @param count The number of results to return
     * @param from The number of results to skip
     */
    public offeracceptlist(aliases?: Array<string>, guid?: string, filterpurchases?: boolean, filtersales?: boolean, count?: number, from?: number, extraHttpRequestParams?: any): Observable<Array<OfferAccept>> {
        return this.offeracceptlistWithHttpInfo(aliases, guid, filterpurchases, filtersales, count, from, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Add to the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offeraddwhitelist(request: OfferAddWhitelistRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeraddwhitelistWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Clear the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerclearwhitelist(request: OfferClearWhitelistRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerclearwhitelistWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Count offers that an array of aliases own.
     * @param aliases 
     */
    public offercount(aliases?: Array<string>, extraHttpRequestParams?: any): Observable<number> {
        return this.offercountWithHttpInfo(aliases, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * scan and filter offers
     * @param regexp apply [regexp] on offeres, empty means all offers
     * @param from show results from number [from]
     * @param count the number of results to return
     * @param safesearch shows all offers that are safe to display (not on the ban list)
     * @param category Category you want to search in, empty for all
     */
    public offerfilter(regexp?: string, from?: string, count?: number, safesearch?: string, category?: string, extraHttpRequestParams?: any): Observable<Array<Offer>> {
        return this.offerfilterWithHttpInfo(regexp, from, count, safesearch, category, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * List all stored values of an offer.
     * @param offer Offer GUID.
     */
    public offerhistory(offer: string, extraHttpRequestParams?: any): Observable<Array<OfferHistoryEntry>> {
        return this.offerhistoryWithHttpInfo(offer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Show values of an offer.
     * @param guid 
     */
    public offerinfo(guid: string, extraHttpRequestParams?: any): Observable<Offer> {
        return this.offerinfoWithHttpInfo(guid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerlink(request: OfferLinkRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerlinkWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * list offers that an array of aliases own.
     * @param aliases 
     * @param guid 
     * @param count The number of results to return
     * @param from The number of results to skip
     */
    public offerlist(aliases?: Array<string>, guid?: string, count?: number, from?: number, extraHttpRequestParams?: any): Observable<Array<Offer>> {
        return this.offerlistWithHttpInfo(aliases, guid, count, from, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Create a new offer on the Syscoin decentralized marketplace. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offernew(request: OfferNewRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offernewWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Remove from the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerremovewhitelist(request: OfferRemoveWhitelistRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerremovewhitelistWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Perform an update on an offer you control. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerupdate(request: OfferUpdateRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerupdateWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * List all affiliates for this offer.
     * @param offerguid 
     */
    public offerwhitelist(offerguid: string, extraHttpRequestParams?: any): Observable<Array<OfferWhitelistEntry>> {
        return this.offerwhitelistWithHttpInfo(offerguid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * 
     * Accept&amp;Pay for a confirmed offer.
     * @param request 
     */
    public offeracceptWithHttpInfo(request: OfferAcceptRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offeraccept';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offeraccept.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Acknowledge offer payment as seller of offer. Deducts qty of offer and increases number of sold inventory.
     * @param offerguid 
     * @param offeracceptguid 
     */
    public offeracceptacknowledgeWithHttpInfo(offerguid: string, offeracceptguid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offeracceptacknowledge';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'offerguid' is not null or undefined
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offeracceptacknowledge.');
        }
        // verify required parameter 'offeracceptguid' is not null or undefined
        if (offeracceptguid === null || offeracceptguid === undefined) {
            throw new Error('Required parameter offeracceptguid was null or undefined when calling offeracceptacknowledge.');
        }
        if (offerguid !== undefined) {
            queryParameters.set('offerguid', <any>offerguid);
        }

        if (offeracceptguid !== undefined) {
            queryParameters.set('offeracceptguid', <any>offeracceptguid);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List count of offer accept for a set of aliases. filterpurchases filters results for count of accepts that have been bought with aliases passed in(as buyer), filtersales filters results for count of accepts purchased by aliases passed in(as merchant or affiliate).
     * @param aliases 
     * @param filterpurchases 
     * @param filtersales 
     */
    public offeracceptcountWithHttpInfo(aliases?: Array<string>, filterpurchases?: boolean, filtersales?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offeracceptcount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (aliases) {
            queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }

        if (filterpurchases !== undefined) {
            queryParameters.set('filterpurchases', <any>filterpurchases);
        }

        if (filtersales !== undefined) {
            queryParameters.set('filtersales', <any>filtersales);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Send feedback and rating for offer accept specified. Ratings are numbers from 1 to 5
     * @param offerguid 
     * @param offeracceptguid 
     * @param feedback 
     * @param rating 
     */
    public offeracceptfeedbackWithHttpInfo(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offeracceptfeedback';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'offerguid' is not null or undefined
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offeracceptfeedback.');
        }
        // verify required parameter 'offeracceptguid' is not null or undefined
        if (offeracceptguid === null || offeracceptguid === undefined) {
            throw new Error('Required parameter offeracceptguid was null or undefined when calling offeracceptfeedback.');
        }
        if (offerguid !== undefined) {
            queryParameters.set('offerguid', <any>offerguid);
        }

        if (offeracceptguid !== undefined) {
            queryParameters.set('offeracceptguid', <any>offeracceptguid);
        }

        if (feedback !== undefined) {
            queryParameters.set('feedback', <any>feedback);
        }

        if (rating !== undefined) {
            queryParameters.set('rating', <any>rating);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List offer accepts for a set of aliases. filterpurchases filters results for accepts that have been bought with aliases passed in(as buyer), filtersales filters results for accepts purchased by aliases passed in(as merchant or affiliate).
     * @param aliases 
     * @param guid 
     * @param filterpurchases 
     * @param filtersales 
     * @param count The number of results to return
     * @param from The number of results to skip
     */
    public offeracceptlistWithHttpInfo(aliases?: Array<string>, guid?: string, filterpurchases?: boolean, filtersales?: boolean, count?: number, from?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offeracceptlist';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (aliases) {
            queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }

        if (guid !== undefined) {
            queryParameters.set('guid', <any>guid);
        }

        if (filterpurchases !== undefined) {
            queryParameters.set('filterpurchases', <any>filterpurchases);
        }

        if (filtersales !== undefined) {
            queryParameters.set('filtersales', <any>filtersales);
        }

        if (count !== undefined) {
            queryParameters.set('count', <any>count);
        }

        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Add to the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offeraddwhitelistWithHttpInfo(request: OfferAddWhitelistRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offeraddwhitelist';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offeraddwhitelist.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Clear the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerclearwhitelistWithHttpInfo(request: OfferClearWhitelistRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerclearwhitelist';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerclearwhitelist.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Count offers that an array of aliases own.
     * @param aliases 
     */
    public offercountWithHttpInfo(aliases?: Array<string>, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offercount';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (aliases) {
            queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * scan and filter offers
     * @param regexp apply [regexp] on offeres, empty means all offers
     * @param from show results from number [from]
     * @param count the number of results to return
     * @param safesearch shows all offers that are safe to display (not on the ban list)
     * @param category Category you want to search in, empty for all
     */
    public offerfilterWithHttpInfo(regexp?: string, from?: string, count?: number, safesearch?: string, category?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerfilter';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (regexp !== undefined) {
            queryParameters.set('regexp', <any>regexp);
        }

        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }

        if (count !== undefined) {
            queryParameters.set('count', <any>count);
        }

        if (safesearch !== undefined) {
            queryParameters.set('safesearch', <any>safesearch);
        }

        if (category !== undefined) {
            queryParameters.set('category', <any>category);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List all stored values of an offer.
     * @param offer Offer GUID.
     */
    public offerhistoryWithHttpInfo(offer: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerhistory';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'offer' is not null or undefined
        if (offer === null || offer === undefined) {
            throw new Error('Required parameter offer was null or undefined when calling offerhistory.');
        }
        if (offer !== undefined) {
            queryParameters.set('offer', <any>offer);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Show values of an offer.
     * @param guid 
     */
    public offerinfoWithHttpInfo(guid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerinfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling offerinfo.');
        }
        if (guid !== undefined) {
            queryParameters.set('guid', <any>guid);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerlinkWithHttpInfo(request: OfferLinkRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerlink';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerlink.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * list offers that an array of aliases own.
     * @param aliases 
     * @param guid 
     * @param count The number of results to return
     * @param from The number of results to skip
     */
    public offerlistWithHttpInfo(aliases?: Array<string>, guid?: string, count?: number, from?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerlist';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (aliases) {
            queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }

        if (guid !== undefined) {
            queryParameters.set('guid', <any>guid);
        }

        if (count !== undefined) {
            queryParameters.set('count', <any>count);
        }

        if (from !== undefined) {
            queryParameters.set('from', <any>from);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Create a new offer on the Syscoin decentralized marketplace. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offernewWithHttpInfo(request: OfferNewRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offernew';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offernew.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Remove from the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerremovewhitelistWithHttpInfo(request: OfferRemoveWhitelistRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerremovewhitelist';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerremovewhitelist.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Perform an update on an offer you control. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerupdateWithHttpInfo(request: OfferUpdateRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerupdate';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerupdate.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List all affiliates for this offer.
     * @param offerguid 
     */
    public offerwhitelistWithHttpInfo(offerguid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/offerwhitelist';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'offerguid' is not null or undefined
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offerwhitelist.');
        }
        if (offerguid !== undefined) {
            queryParameters.set('offerguid', <any>offerguid);
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKeys["token"]) {
            headers.set('token', this.configuration.apiKeys["token"]);
        }

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
